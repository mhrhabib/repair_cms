import 'dart:convert';
import 'dart:io';

import 'package:repair_cms/core/app_exports.dart';
import 'package:repair_cms/core/helpers/contact_data_helper.dart';
import 'package:repair_cms/core/helpers/storage.dart';
import 'package:repair_cms/features/jobBooking/models/create_job_request.dart';
part 'job_booking_state.dart';

class JobBookingCubit extends Cubit<JobBookingState> {
  JobBookingCubit() : super(JobBookingInitial());

  // Helper method to validate MongoDB ObjectId
  bool _isValidObjectId(String? id) {
    if (id == null || id.isEmpty) return false;
    final objectIdRegex = RegExp(r'^[0-9a-fA-F]{24}$');
    return objectIdRegex.hasMatch(id);
  }

  // Add this method to your JobBookingCubit
  void updateCustomerSignature(String signatureBase64) {
    final state = this.state;
    if (state is JobBookingData) {
      emit(state.copyWith(job: state.job.copyWith(signatureFilePath: signatureBase64)));
    }
  }

  // Initialize with empty data
  void initializeJob() {
    // Get valid ObjectIds from storage
    final storedUserId = storage.read('userId');
    final storedLocationId = storage.read('locationId');

    // Get receipt data from storage
    final receiptDataJson = storage.read('jobReceiptData');
    String salutationHTMLmarkup = '';
    String termsAndConditionsHTMLmarkup = '';

    if (receiptDataJson != null) {
      try {
        final receiptData = jsonDecode(receiptDataJson);
        salutationHTMLmarkup = receiptData['salutation'] ?? '';
        termsAndConditionsHTMLmarkup = receiptData['termsAndConditions'] ?? '';
        debugPrint('‚úÖ [JobBookingCubit] Loaded receipt data from storage');
        debugPrint('üìÑ [JobBookingCubit] Salutation length: ${salutationHTMLmarkup.length}');
        debugPrint('üìÑ [JobBookingCubit] Terms length: ${termsAndConditionsHTMLmarkup.length}');
      } catch (e) {
        debugPrint('‚ùå [JobBookingCubit] Error parsing receipt data: $e');
      }
    } else {
      debugPrint('‚ö†Ô∏è [JobBookingCubit] No receipt data found in storage');
    }

    emit(
      JobBookingData(
        job: Job(
          jobType: "express",
          jobTypes: "",
          model: "",
          servicesIds: [],
          assignedItemsIds: [],
          userId: _isValidObjectId(storedUserId) ? storedUserId : "", // Set from storage if valid
          loggedUserId: _isValidObjectId(storedUserId) ? storedUserId : "", // Set from storage if valid
          jobStatus: [],
          status: "draft",
          discount: 0,
          vat: 0,
          subTotal: 0,
          total: 0,
          jobNo: "", // Will be generated by backend
          customerId: "",
          customerDetails: CustomerDetails(
            customerId: "",
            type: "Personal",
            type2: "personal",
            organization: "",
            customerNo: "",
            email: "",
            telephone: "",
            telephonePrefix: "+1", // Default prefix
            shippingAddress: CustomerAddress(street: "", no: "", zip: "", city: "", state: "", country: ""),
            billingAddress: CustomerAddress(street: "", no: "", zip: "", city: "", state: "", country: ""),
            salutation: "",
            firstName: "",
            lastName: "",
            position: "",
            vatNo: "",
            reverseCharge: false,
          ),
          files: [],
          location: _isValidObjectId(storedLocationId) ? storedLocationId : "", // Set from storage if valid
          physicalLocation: "",
          signatureFilePath: "",
          salutationHTMLmarkup: salutationHTMLmarkup, // From receipt data
          termsAndConditionsHTMLmarkup: termsAndConditionsHTMLmarkup, // From receipt data
          receiptFooter: ReceiptFooter(
            companyLogo: "",
            companyLogoURL: "",
            address: CompanyAddress(companyName: "", street: "", num: "", zip: "", city: "", country: ""),
            contact: CompanyContact(ceo: "", telephone: "", email: "", website: ""),
            bank: BankDetails(bankName: "", iban: "", bic: ""),
          ),
          printOption: "A4 Receipt",
          emailConfirmation: true,
          printDeviceLabel: false,
        ),
        defect: Defect(jobType: "", defect: [], internalNote: []),
        device: Device(category: "", brand: "", model: "", imei: "", condition: [], deviceSecurity: "no security"),
        contact: Contact(
          type: "Personal",
          customerId: "",
          type2: "personal",
          organization: "",
          customerNo: "",
          email: "",
          telephone: "",
          telephonePrefix: "+1",
          shippingAddress: CustomerAddress(street: "", no: "", zip: "", city: "", state: "", country: ""),
          billingAddress: CustomerAddress(street: "", no: "", zip: "", city: "", state: "", country: ""),
          salutation: "",
          firstName: "",
          lastName: "",
          position: "",
          vatNo: "",
          reverseCharge: false,
        ),
        currentStep: 0,
        localFiles: [],
      ),
    );
  }

  // Update customer information
  void updateCustomerInfo({
    String? salutation,
    String? firstName,
    String? lastName,
    String? telephone,
    String? telephonePrefix,
    String? email,
    String? customerId,
  }) {
    final state = this.state;
    if (state is JobBookingData) {
      emit(
        state.copyWith(
          contact: state.contact.copyWith(
            salutation: salutation ?? state.contact.salutation,
            firstName: firstName ?? state.contact.firstName,
            lastName: lastName ?? state.contact.lastName,
            telephone: telephone ?? state.contact.telephone,
            telephonePrefix: telephonePrefix ?? state.contact.telephonePrefix,
            email: email ?? state.contact.email,
            customerId: customerId ?? state.contact.customerId,
          ),
          job: state.job.copyWith(
            customerDetails: state.job.customerDetails.copyWith(
              salutation: salutation ?? state.job.customerDetails.salutation,
              firstName: firstName ?? state.job.customerDetails.firstName,
              lastName: lastName ?? state.job.customerDetails.lastName,
              telephone: telephone ?? state.job.customerDetails.telephone,
              telephonePrefix: telephonePrefix ?? state.job.customerDetails.telephonePrefix,
              email: email ?? state.job.customerDetails.email,
              customerId: customerId ?? state.job.customerDetails.customerId,
            ),
          ),
        ),
      );
    }
  }

  // Store job ID after creation
  void setJobId(String jobId) {
    final state = this.state;
    if (state is JobBookingData) {
      emit(state.copyWith(jobId: jobId));
    }
  }

  // Update contact type and business information
  void updateContactType({
    String? type,
    String? type2,
    String? organization,
    String? customerNo,
    String? position,
    String? vatNo,
    bool? reverseCharge,
  }) {
    final state = this.state;
    if (state is JobBookingData) {
      emit(
        state.copyWith(
          contact: state.contact.copyWith(
            type: type ?? state.contact.type,
            type2: type2 ?? state.contact.type2,
            organization: organization ?? state.contact.organization,
            customerNo: customerNo ?? state.contact.customerNo,
            position: position ?? state.contact.position,
            vatNo: vatNo ?? state.contact.vatNo,
            reverseCharge: reverseCharge ?? state.contact.reverseCharge,
          ),
          job: state.job.copyWith(
            customerDetails: state.job.customerDetails.copyWith(
              type: type ?? state.job.customerDetails.type,
              type2: type2 ?? state.job.customerDetails.type2,
              organization: organization ?? state.job.customerDetails.organization,
              customerNo: customerNo ?? state.job.customerDetails.customerNo,
              position: position ?? state.job.customerDetails.position,
              vatNo: vatNo ?? state.job.customerDetails.vatNo,
              reverseCharge: reverseCharge ?? state.job.customerDetails.reverseCharge,
            ),
          ),
        ),
      );
    }
  }

  // Update device information
  void updateDeviceInfo({
    String? category,
    String? brand,
    String? model,
    String? imei,
    List<ConditionItem>? condition,
    String? deviceSecurity,
  }) {
    final state = this.state;
    if (state is JobBookingData) {
      emit(
        state.copyWith(
          device: state.device.copyWith(
            category: category ?? state.device.category,
            brand: brand ?? state.device.brand,
            model: model ?? state.device.model,
            imei: imei ?? state.device.imei,
            condition: condition ?? state.device.condition,
            deviceSecurity: deviceSecurity ?? state.device.deviceSecurity,
          ),
          job: state.job.copyWith(model: model ?? state.job.model),
        ),
      );
    }
  }

  // Update services
  void updateServices(List<String> servicesIds) {
    final state = this.state;
    if (state is JobBookingData) {
      emit(state.copyWith(job: state.job.copyWith(servicesIds: servicesIds)));
    }
  }

  // Add a service
  void addService(String serviceId) {
    final state = this.state;
    if (state is JobBookingData) {
      final updatedServices = List<String>.from(state.job.servicesIds)..add(serviceId);
      emit(state.copyWith(job: state.job.copyWith(servicesIds: updatedServices)));
    }
  }

  // Remove a service
  void removeService(String serviceId) {
    final state = this.state;
    if (state is JobBookingData) {
      final updatedServices = List<String>.from(state.job.servicesIds)..remove(serviceId);
      emit(state.copyWith(job: state.job.copyWith(servicesIds: updatedServices)));
    }
  }

  // Update assigned items
  void updateAssignedItems(List<String> assignedItemsIds) {
    final state = this.state;
    if (state is JobBookingData) {
      emit(state.copyWith(job: state.job.copyWith(assignedItemsIds: assignedItemsIds)));
    }
  }

  // Update defect information
  void updateDefectInfo({String? jobType, List<DefectItem>? defect, List<dynamic>? internalNote}) {
    final state = this.state;
    if (state is JobBookingData) {
      emit(
        state.copyWith(
          defect: state.defect.copyWith(
            jobType: jobType ?? state.defect.jobType,
            defect: defect ?? state.defect.defect,
            internalNote: internalNote ?? state.defect.internalNote,
          ),
          job: state.job.copyWith(jobTypes: jobType ?? state.job.jobTypes),
        ),
      );
    }
  }

  // Update pricing information
  void updatePricing({double? discount, double? vat, double? subTotal, double? total}) {
    final state = this.state;
    if (state is JobBookingData) {
      emit(
        state.copyWith(
          job: state.job.copyWith(
            discount: discount ?? state.job.discount,
            vat: vat ?? state.job.vat,
            subTotal: subTotal ?? state.job.subTotal,
            total: total ?? state.job.total,
          ),
        ),
      );
    }
  }

  // Update addresses
  void updateShippingAddress(CustomerAddress address) {
    final state = this.state;
    if (state is JobBookingData) {
      emit(
        state.copyWith(
          contact: state.contact.copyWith(shippingAddress: address),
          job: state.job.copyWith(customerDetails: state.job.customerDetails.copyWith(shippingAddress: address)),
        ),
      );
    }
  }

  void updateBillingAddress(CustomerAddress address) {
    final state = this.state;
    if (state is JobBookingData) {
      emit(
        state.copyWith(
          contact: state.contact.copyWith(billingAddress: address),
          job: state.job.copyWith(customerDetails: state.job.customerDetails.copyWith(billingAddress: address)),
        ),
      );
    }
  }

  // Update current step
  void updateCurrentStep(int step) {
    final state = this.state;
    if (state is JobBookingData) {
      emit(state.copyWith(currentStep: step));
    }
  }

  // Set user and location data (from authentication/context)
  void setUserData({required String userId, required String loggedUserId, required String location}) {
    final state = this.state;
    if (state is JobBookingData) {
      emit(
        state.copyWith(
          job: state.job.copyWith(
            userId: _isValidObjectId(userId) ? userId : state.job.userId,
            loggedUserId: _isValidObjectId(loggedUserId) ? loggedUserId : state.job.loggedUserId,
            location: _isValidObjectId(location) ? location : state.job.location,
          ),
        ),
      );
    }
  }

  // Generate job status
  void generateJobStatus(String userName) {
    final state = this.state;
    if (state is JobBookingData) {
      // Get valid userId for job status
      final storedUserId = storage.read('userId');
      final validUserId = _isValidObjectId(state.job.userId)
          ? state.job.userId!
          : (_isValidObjectId(storedUserId) ? storedUserId : '');

      if (validUserId.isEmpty) {
        debugPrint('‚ùå [JobBookingCubit] No valid userId available for job status');
        return;
      }

      final jobStatus = JobStatus(
        title: "draft",
        userId: validUserId,
        colorCode: "#2589F6",
        userName: userName,
        createAtStatus: DateTime.now().millisecondsSinceEpoch,
        notifications: true,
        notes: "new_job_in_draft",
      );

      emit(
        state.copyWith(
          job: state.job.copyWith(status: 'draft', jobStatus: [jobStatus]),
        ),
      );
      debugPrint('‚úÖ [JobBookingCubit] Generated draft job status with userId: $validUserId');
    }
  }

  // Update job status to booked
  void updateJobStatusToBooked({required String userId, required String userName, required String email}) {
    final state = this.state;
    if (state is JobBookingData) {
      // Get valid userId for job status
      final validUserId = _isValidObjectId(userId) ? userId : '';

      if (validUserId.isEmpty) {
        debugPrint('‚ùå [JobBookingCubit] No valid userId available for booked job status');
        return;
      }

      final bookedJobStatus = JobStatus(
        title: "booked",
        userId: validUserId,
        colorCode: "#2589F6",
        userName: userName,
        createAtStatus: DateTime.now().millisecondsSinceEpoch,
        notifications: true,
        email: email,
        notes: "new_job_created",
      );

      emit(
        state.copyWith(
          job: state.job.copyWith(status: 'booked', jobStatus: [bookedJobStatus]),
        ),
      );
      debugPrint('‚úÖ [JobBookingCubit] Updated to booked status with userId: $validUserId');
    }
  }

  // Update job with data from created job response
  void updateJobFromResponse(JobData createdJobData) {
    final state = this.state;
    if (state is JobBookingData) {
      emit(
        state.copyWith(
          job: state.job.copyWith(
            jobNo: createdJobData.jobNo ?? state.job.jobNo,
            customerId: createdJobData.jobContactId ?? state.job.customerId,
            // Keep other fields from the response that might be important
          ),
        ),
      );
      debugPrint('‚úÖ [JobBookingCubit] Updated job with jobNo: ${createdJobData.jobNo}');
    }
  }

  // Get the final request for API call
  CreateJobRequest getCreateJobRequest() {
    final state = this.state;
    if (state is JobBookingData) {
      return CreateJobRequest(job: state.job, defect: state.defect, device: state.device, contact: state.contact);
    }
    throw Exception("Job data not initialized");
  }

  // Clear all data
  void clearData() {
    emit(JobBookingInitial());
  }

  // Check if all required data is filled
  bool isDataComplete() {
    final state = this.state;
    if (state is JobBookingData) {
      return state.contact.firstName.isNotEmpty &&
          state.contact.lastName.isNotEmpty &&
          state.contact.telephone.isNotEmpty &&
          state.device.brand.isNotEmpty &&
          state.device.model.isNotEmpty &&
          state.device.category.isNotEmpty &&
          state.job.servicesIds.isNotEmpty;
    }
    return false;
  }

  // Get progress percentage
  double getProgressPercentage() {
    final state = this.state;
    if (state is JobBookingData) {
      int completedFields = 0;
      int totalFields = 7; // Adjust based on your required fields

      if (state.contact.firstName.isNotEmpty) completedFields++;
      if (state.contact.lastName.isNotEmpty) completedFields++;
      if (state.contact.telephone.isNotEmpty) completedFields++;
      if (state.device.brand.isNotEmpty) completedFields++;
      if (state.device.model.isNotEmpty) completedFields++;
      if (state.device.category.isNotEmpty) completedFields++;
      if (state.job.servicesIds.isNotEmpty) completedFields++;

      return completedFields / totalFields;
    }
    return 0.0;
  }

  // Method to update from contact data (using your helper functions)
  void updateFromContactData(Map<String, dynamic> contactData, {String option = 'select'}) {
    final businessData = ContactDataHelper.getContactDataForJobContact(contactData, option: option);

    updateContactType(
      type: businessData['type'],
      type2: businessData['type2'],
      organization: businessData['organization'],
      customerNo: businessData['customerNo'],
      position: businessData['position'],
      vatNo: businessData['vatNo'],
      reverseCharge: businessData['reverseCharge'],
    );

    updateCustomerInfo(
      salutation: businessData['salutation'],
      firstName: businessData['firstName'],
      lastName: businessData['lastName'],
      telephone: businessData['telephone'],
      telephonePrefix: businessData['telephone_prefix'],
      email: businessData['email'],
      customerId: businessData['customerId'],
    );

    // Update addresses if available
    if (businessData['shipping_address'] != null) {
      final shippingAddressData = businessData['shipping_address'] as Map<String, dynamic>;
      final shippingAddress = CustomerAddress(
        street: shippingAddressData['street'] ?? '',
        no: shippingAddressData['no'] ?? '',
        zip: shippingAddressData['zip'] ?? '',
        city: shippingAddressData['city'] ?? '',
        state: shippingAddressData['state'] ?? '',
        country: shippingAddressData['country'] ?? '',
      );
      updateShippingAddress(shippingAddress);
    }

    if (businessData['billing_address'] != null) {
      final billingAddressData = businessData['billing_address'] as Map<String, dynamic>;
      final billingAddress = CustomerAddress(
        street: billingAddressData['street'] ?? '',
        no: billingAddressData['no'] ?? '',
        zip: billingAddressData['zip'] ?? '',
        city: billingAddressData['city'] ?? '',
        state: billingAddressData['state'] ?? '',
        country: billingAddressData['country'] ?? '',
      );
      updateBillingAddress(billingAddress);
    }
  }

  // Add to your existing JobBookingCubit

  // Add an item to assigned items
  void addItem(String itemId) {
    final state = this.state;
    if (state is JobBookingData) {
      final updatedItems = List<String>.from(state.job.assignedItemsIds)..add(itemId);
      emit(state.copyWith(job: state.job.copyWith(assignedItemsIds: updatedItems)));
    }
  }

  // Remove an item from assigned items
  void removeItem(String itemId) {
    final state = this.state;
    if (state is JobBookingData) {
      final updatedItems = List<String>.from(state.job.assignedItemsIds)..remove(itemId);
      emit(state.copyWith(job: state.job.copyWith(assignedItemsIds: updatedItems)));
    }
  }

  // Clear all assigned items
  void clearAssignedItems() {
    final state = this.state;
    if (state is JobBookingData) {
      emit(state.copyWith(job: state.job.copyWith(assignedItemsIds: [])));
    }
  }

  // Get assigned items count
  int getAssignedItemsCount() {
    final state = this.state;
    if (state is JobBookingData) {
      return state.job.assignedItemsIds.length;
    }
    return 0;
  }

  // Check if item is already assigned
  bool isItemAssigned(String itemId) {
    final state = this.state;
    if (state is JobBookingData) {
      return state.job.assignedItemsIds.contains(itemId);
    }
    return false;
  }

  // Add these methods to your existing JobBookingCubit

  // Update physical location
  void updatePhysicalLocation(String location) {
    final state = this.state;
    if (state is JobBookingData) {
      // Store location in the job
      emit(
        state.copyWith(
          job: state.job.copyWith(
            physicalLocation: location,
            location: _isValidObjectId(storage.read("locationId")) ? storage.read("locationId") : state.job.location,
            loggedUserId: _isValidObjectId(storage.read("userId")) ? storage.read("userId") : state.job.loggedUserId,
            userId: _isValidObjectId(storage.read("userId")) ? storage.read("userId") : state.job.userId,
          ),
        ),
      );
    }
  }

  // Update print option
  void updatePrintOption(String printOption) {
    final state = this.state;
    if (state is JobBookingData) {
      // Set printDeviceLabel to true only for "Device Label" option
      final isPrintDeviceLabel = printOption == "Device Label";
      emit(
        state.copyWith(
          job: state.job.copyWith(printOption: printOption, printDeviceLabel: isPrintDeviceLabel),
        ),
      );
    }
  }

  //update files
  // Add single file with both representations
  void addFileWithPreview(File localFile, AvatarFile avatarFile) {
    final state = this.state;
    if (state is JobBookingData) {
      final updatedLocalFiles = List<File>.from(state.localFiles!)..add(localFile);
      final updatedAvatarFiles = List<AvatarFile>.from(state.job.files ?? [])..add(avatarFile);
      final updatedJob = state.job.copyWith(files: updatedAvatarFiles);

      emit(state.copyWith(job: updatedJob, localFiles: updatedLocalFiles));
    }
  }

  // Add multiple files
  void addFilesWithPreviews(List<File> localFiles, List<AvatarFile> avatarFiles) {
    final state = this.state;
    if (state is JobBookingData) {
      final updatedLocalFiles = List<File>.from(state.localFiles!)..addAll(localFiles);
      final updatedAvatarFiles = List<AvatarFile>.from(state.job.files ?? [])..addAll(avatarFiles);
      final updatedJob = state.job.copyWith(files: updatedAvatarFiles);

      emit(state.copyWith(job: updatedJob, localFiles: updatedLocalFiles));
    }
  }

  // Remove file by index
  void removeFile(int index) {
    final state = this.state;
    if (state is JobBookingData) {
      if (index >= 0 && index < state.localFiles!.length && index < (state.job.files?.length ?? 0)) {
        final updatedLocalFiles = List<File>.from(state.localFiles!)..removeAt(index);
        final updatedAvatarFiles = List<AvatarFile>.from(state.job.files ?? [])..removeAt(index);
        final updatedJob = state.job.copyWith(files: updatedAvatarFiles);

        emit(state.copyWith(job: updatedJob, localFiles: updatedLocalFiles));
      }
    }
  }

  // Clear all files
  void clearFiles() {
    final state = this.state;
    if (state is JobBookingData) {
      final updatedJob = state.job.copyWith(files: []);
      emit(state.copyWith(job: updatedJob, localFiles: []));
    }
  }

  // Set uploading status
  void setUploadingStatus(bool isUploading) {
    final state = this.state;
    if (state is JobBookingData) {
      emit(state.copyWith(isUploading: isUploading));
    }
  }

  // Update receipt data from storage (call this when receipt data changes)
  void updateReceiptData() {
    final receiptDataJson = storage.read('jobReceiptData');
    if (receiptDataJson != null && state is JobBookingData) {
      try {
        final receiptData = jsonDecode(receiptDataJson);
        final salutationHTMLmarkup = receiptData['salutation'] ?? '';
        final termsAndConditionsHTMLmarkup = receiptData['termsAndConditions'] ?? '';

        final currentState = state as JobBookingData;
        emit(
          currentState.copyWith(
            job: currentState.job.copyWith(
              salutationHTMLmarkup: salutationHTMLmarkup,
              termsAndConditionsHTMLmarkup: termsAndConditionsHTMLmarkup,
            ),
          ),
        );

        debugPrint('‚úÖ [JobBookingCubit] Updated receipt data in job');
        debugPrint('üìÑ [JobBookingCubit] Salutation length: ${salutationHTMLmarkup.length}');
        debugPrint('üìÑ [JobBookingCubit] Terms length: ${termsAndConditionsHTMLmarkup.length}');
      } catch (e) {
        debugPrint('‚ùå [JobBookingCubit] Error updating receipt data: $e');
      }
    }
  }

  // Update receipt footer with company information
  void updateReceiptFooterFromCompany(dynamic companyModel) {
    final currentState = state;
    if (currentState is! JobBookingData) {
      debugPrint('‚ö†Ô∏è [JobBookingCubit] Cannot update receipt footer - state is not JobBookingData');
      return;
    }

    try {
      debugPrint('üè¢ [JobBookingCubit] Starting receipt footer update from company data');
      debugPrint('üìä [JobBookingCubit] Company name: ${companyModel.companyName}');

      // Extract company logo
      final companyLogoURL = companyModel.companyLogo != null && companyModel.companyLogo!.isNotEmpty
          ? companyModel.companyLogo![0].image ?? ''
          : '';
      debugPrint('üñºÔ∏è [JobBookingCubit] Logo URL: $companyLogoURL');

      // Extract company address
      final companyAddress = companyModel.companyAddress != null && companyModel.companyAddress!.isNotEmpty
          ? companyModel.companyAddress![0]
          : null;

      final address = CompanyAddress(
        companyName: companyModel.companyName ?? '',
        street: companyAddress?.street ?? '',
        num: companyAddress?.num ?? '',
        zip: companyAddress?.zip ?? '',
        city: companyAddress?.city ?? '',
        country: companyAddress?.country ?? '',
      );
      debugPrint(
        'üìç [JobBookingCubit] Address: ${address.street} ${address.num}, ${address.zip} ${address.city}, ${address.country}',
      );

      // Extract company contact details
      final companyContact = companyModel.companyContactDetail != null && companyModel.companyContactDetail!.isNotEmpty
          ? companyModel.companyContactDetail![0]
          : null;

      // Extract company tax details (for CEO name)
      final companyTax = companyModel.companyTaxDetail != null && companyModel.companyTaxDetail!.isNotEmpty
          ? companyModel.companyTaxDetail![0]
          : null;

      final contact = CompanyContact(
        ceo: companyTax?.ceo ?? '',
        telephone: companyContact?.telephone ?? companyModel.telephone ?? '',
        email: companyContact?.email ?? companyModel.companyEmail ?? '',
        website: companyContact?.website ?? '',
      );
      debugPrint(
        'üìû [JobBookingCubit] Contact - CEO: ${contact.ceo}, Tel: ${contact.telephone}, Email: ${contact.email}, Web: ${contact.website}',
      );

      // Extract bank details
      final companyBank = companyModel.companyBankDetail != null && companyModel.companyBankDetail!.isNotEmpty
          ? companyModel.companyBankDetail![0]
          : null;

      final bank = BankDetails(
        bankName: companyBank?.bankName ?? '',
        iban: companyBank?.iban ?? '',
        bic: companyBank?.bic ?? '',
      );
      debugPrint('üè¶ [JobBookingCubit] Bank - Name: ${bank.bankName}, IBAN: ${bank.iban}, BIC: ${bank.bic}');

      // Create updated receipt footer
      final updatedReceiptFooter = ReceiptFooter(
        companyLogo: '', // Empty as it's stored in URL
        companyLogoURL: companyLogoURL,
        address: address,
        contact: contact,
        bank: bank,
      );

      // Update job with new receipt footer
      emit(currentState.copyWith(job: currentState.job.copyWith(receiptFooter: updatedReceiptFooter)));

      debugPrint('‚úÖ [JobBookingCubit] Receipt footer updated successfully');
      debugPrint('üìã [JobBookingCubit] Summary:');
      debugPrint('   - Company: ${companyModel.companyName}');
      debugPrint('   - Logo: ${companyLogoURL.isNotEmpty ? "‚úì" : "‚úó"}');
      debugPrint('   - Address: ${address.city.isNotEmpty ? "‚úì" : "‚úó"}');
      debugPrint('   - Contact: ${contact.telephone.isNotEmpty ? "‚úì" : "‚úó"}');
      debugPrint('   - Bank: ${bank.iban.isNotEmpty ? "‚úì" : "‚úó"}');
    } catch (e, stackTrace) {
      debugPrint('‚ùå [JobBookingCubit] Error updating receipt footer: $e');
      debugPrint('üìã [JobBookingCubit] Stack trace: $stackTrace');
    }
  }

  // Process and add file (for file upload functionality)
  Future<void> processAndAddFile(String filePath) async {
    final state = this.state;
    if (state is! JobBookingData) return;

    setUploadingStatus(true);

    try {
      // Read file and convert to base64
      final localFile = File(filePath);
      if (!await localFile.exists()) {
        throw Exception("File does not exist: $filePath");
      }

      final bytes = await localFile.readAsBytes();
      final base64Image = base64Encode(bytes);
      final mimeType = "image/jpeg"; // Default MIME type for images
      final base64String = "data:$mimeType;base64,$base64Image";

      // Create AvatarFile with base64 data
      final avatarFile = AvatarFile(file: base64String);

      // Add both representations
      addFileWithPreview(localFile, avatarFile);
    } catch (e) {
      rethrow;
    } finally {
      setUploadingStatus(false);
    }
  }
}
